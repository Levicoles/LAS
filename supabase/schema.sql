-- Supabase SQL schema for Library Attendance System

-- Books table
create table if not exists public.books (
  id bigint generated by default as identity primary key,
  title text not null,
  author text not null,
  shelf integer not null check (shelf > 0),
  available boolean not null default true,
  isbn text null,
  photo_url text null,
  description text null,
  created_at timestamptz not null default now()
);

-- Students table
create table if not exists public.students (
  id bigint generated by default as identity primary key,
  lrn text not null unique,
  name text not null,
  year_level text not null,
  section text not null,
  created_at timestamptz not null default now()
);

-- Attendance table
create table if not exists public.attendance (
  id bigint generated by default as identity primary key,
  student_id bigint not null references public.students(id) on delete cascade,
  check_in timestamptz not null default now(),
  check_out timestamptz null,
  created_at timestamptz not null default now()
);

-- Convenience view for recent activity
create or replace view public.attendance_view as
select 
  a.id,
  case when a.check_out is null then 'in' else 'out' end as type,
  s.name as user,
  (case when a.check_out is null then 'Checked in' else 'Checked out' end) as action,
  coalesce(a.check_out, a.check_in) as time,
  case when a.check_out is not null then age(a.check_out, a.check_in) end as duration
from public.attendance a
join public.students s on s.id = a.student_id;

-- Function to compute average stay time in seconds
create or replace function public.attendance_avg_stay_seconds()
returns table(avg_seconds numeric)
language sql
as $$
  select avg(extract(epoch from (check_out - check_in))) as avg_seconds
  from public.attendance
  where check_out is not null;
$$;

-- Enable RLS but allow anon read/write for prototype (tighten later)
alter table public.books enable row level security;
alter table public.students enable row level security;
alter table public.attendance enable row level security;

do $$
begin
  -- Books policies
  if not exists (
    select 1 from pg_policies where schemaname = 'public' and tablename = 'books' and policyname = 'books_anon_all'
  ) then
    create policy books_anon_all on public.books for all using (true) with check (true);
  end if;

  -- Students policies
  if not exists (
    select 1 from pg_policies where schemaname = 'public' and tablename = 'students' and policyname = 'students_anon_all'
  ) then
    create policy students_anon_all on public.students for all using (true) with check (true);
  end if;

  -- Attendance policies
  if not exists (
    select 1 from pg_policies where schemaname = 'public' and tablename = 'attendance' and policyname = 'attendance_anon_all'
  ) then
    create policy attendance_anon_all on public.attendance for all using (true) with check (true);
  end if;
end$$;



-- Auth helper RPCs (no public tables, only the auth.users table)
-- Returns total number of users in the auth table
create or replace function public.auth_user_count()
returns bigint
language plpgsql
security definer
set search_path = public, auth
as $$
declare
  cnt bigint;
begin
  select count(*) into cnt from auth.users;
  return cnt;
end;
$$;

-- Returns true if there is at least one user with user_metadata.role = 'admin' or 'super_admin'
create or replace function public.has_admin()
returns boolean
language sql
security definer
set search_path = public, auth
as $$
  select exists (
    select 1
    from auth.users u
    where coalesce(u.raw_user_meta_data->>'role', '') in ('admin', 'super_admin')
  );
$$;

-- Returns number of users with role = 'admin' or 'super_admin'
create or replace function public.admin_count()
returns bigint
language sql
security definer
set search_path = public, auth
as $$
  select count(*)::bigint from auth.users u where coalesce(u.raw_user_meta_data->>'role','') in ('admin', 'super_admin');
$$;

-- Returns true if there is at least one super_admin
create or replace function public.has_super_admin()
returns boolean
language sql
security definer
set search_path = public, auth
as $$
  select exists (
    select 1
    from auth.users u
    where coalesce(u.raw_user_meta_data->>'role', '') = 'super_admin'
  );
$$;

-- Get all admin users (for super_admin management)
create or replace function public.get_all_admins()
returns table(
  id uuid,
  email text,
  role text,
  created_at timestamptz,
  last_sign_in_at timestamptz
)
language plpgsql
security definer
set search_path = public, auth
as $$
begin
  return query
  select 
    u.id,
    u.email::text,
    coalesce(u.raw_user_meta_data->>'role', 'user')::text as role,
    u.created_at,
    u.last_sign_in_at
  from auth.users u
  where coalesce(u.raw_user_meta_data->>'role', '') in ('admin', 'super_admin')
  order by u.created_at desc;
end;
$$;

-- Update admin role (super_admin only)
create or replace function public.update_admin_role(target_user_id uuid, new_role text)
returns boolean
language plpgsql
security definer
set search_path = public, auth
as $$
declare
  caller_role text;
begin
  -- Get caller's role
  select coalesce(raw_user_meta_data->>'role', '') into caller_role
  from auth.users where id = auth.uid();
  
  -- Only super_admin can update roles
  if caller_role != 'super_admin' then
    raise exception 'Unauthorized: Only super_admin can update roles';
  end if;
  
  -- Validate new_role
  if new_role not in ('admin', 'super_admin') then
    raise exception 'Invalid role. Must be admin or super_admin';
  end if;
  
  -- Update the user's role
  update auth.users
  set raw_user_meta_data = raw_user_meta_data || jsonb_build_object('role', new_role)
  where id = target_user_id;
  
  return true;
end;
$$;

-- Delete admin account (super_admin only, cannot delete self)
create or replace function public.delete_admin_account(target_user_id uuid)
returns boolean
language plpgsql
security definer
set search_path = public, auth
as $$
declare
  caller_role text;
  caller_id uuid;
begin
  caller_id := auth.uid();
  
  -- Get caller's role
  select coalesce(raw_user_meta_data->>'role', '') into caller_role
  from auth.users where id = caller_id;
  
  -- Only super_admin can delete admins
  if caller_role != 'super_admin' then
    raise exception 'Unauthorized: Only super_admin can delete admin accounts';
  end if;
  
  -- Cannot delete self
  if target_user_id = caller_id then
    raise exception 'Cannot delete your own account';
  end if;
  
  -- Delete the user
  delete from auth.users where id = target_user_id;
  
  return true;
end;
$$;

-- Update admin email (super_admin only)
create or replace function public.update_admin_email(target_user_id uuid, new_email text)
returns boolean
language plpgsql
security definer
set search_path = public, auth
as $$
declare
  caller_role text;
begin
  -- Get caller's role
  select coalesce(raw_user_meta_data->>'role', '') into caller_role
  from auth.users where id = auth.uid();
  
  -- Only super_admin can update admin info
  if caller_role != 'super_admin' then
    raise exception 'Unauthorized: Only super_admin can update admin accounts';
  end if;
  
  -- Update the user's email
  update auth.users
  set email = new_email
  where id = target_user_id;
  
  return true;
end;
$$;

-- Allow anon/authenticated clients to execute these functions
grant execute on function public.auth_user_count() to anon, authenticated;
grant execute on function public.has_admin() to anon, authenticated;
grant execute on function public.admin_count() to anon, authenticated;
grant execute on function public.has_super_admin() to anon, authenticated;
grant execute on function public.get_all_admins() to authenticated;
grant execute on function public.update_admin_role(uuid, text) to authenticated;
grant execute on function public.delete_admin_account(uuid) to authenticated;
grant execute on function public.update_admin_email(uuid, text) to authenticated;

-- Storage bucket for book photos
-- Note: This needs to be run in Supabase dashboard or via CLI as it requires storage_admin role
-- Bucket name: book-photos
-- Public: true
-- Allowed MIME types: image/jpeg, image/png, image/gif, image/webp
-- File size limit: 5242880 (5MB)
-- 
-- Run this SQL in Supabase SQL editor or via CLI:

INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'book-photos',
  'book-photos',
  true,
  5242880,
  ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp']
)
ON CONFLICT (id) DO NOTHING;

-- Storage policies for book-photos bucket
CREATE POLICY "Public Access"
ON storage.objects FOR SELECT
USING (bucket_id = 'book-photos');

CREATE POLICY "Authenticated users can upload"
ON storage.objects FOR INSERT
WITH CHECK (bucket_id = 'book-photos' AND auth.role() = 'authenticated');

CREATE POLICY "Authenticated users can delete"
ON storage.objects FOR DELETE
USING (bucket_id = 'book-photos' AND auth.role() = 'authenticated');
